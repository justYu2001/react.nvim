                                                                *React.toggle()*
                                `React.toggle`()
Toggle the plugin by calling the `enable`/`disable` methods respectively.

------------------------------------------------------------------------------
                                                                *React.enable()*
                            `React.enable`({scope})
Initializes the plugin, sets event listeners and internal state.

------------------------------------------------------------------------------
                                                               *React.disable()*
                               `React.disable`()
Disables the plugin, clear highlight groups and autocmds, closes side buffers and resets the internal state.


==============================================================================
------------------------------------------------------------------------------
                                                                 *React.options*
                                `React.options`
React configuration with its default values.

Type ~
`(table)`
Default values:
>lua
  React.options = {
      -- Prints useful logs about what event are triggered, and reasons actions are executed.
      debug = false,
  }

<
------------------------------------------------------------------------------
                                                                 *React.setup()*
                            `React.setup`({options})
Define your react setup.

Parameters ~
{options} `(table)` Module config table. See |React.options|.

Usage ~
`require("react").setup()` (add `{}` with your |React.options| table)


==============================================================================
------------------------------------------------------------------------------
Class ~
{TSNode}
Fields ~
{range} `(fun(self: TSNode): number,)` number, number, number
{start} `(fun(self: TSNode): number,)` number
{type} `(fun(self: TSNode): string)`
{field} `(fun(self: TSNode, name: string): TSNode[])`
{parent} `(fun(self: TSNode): TSNode|nil)`
{named_child} `(fun(self: TSNode, index: number): TSNode|nil)`
{named_child_count} `(fun(self: TSNode): number)`
{iter_children} `(fun(self: TSNode): fun():)` TSNode, string


==============================================================================
------------------------------------------------------------------------------
                                                                     *M.setup()*
                              `M.setup`({null_ls})
Parameters ~
{null_ls} `(table)` The null-ls module

------------------------------------------------------------------------------
                                                               *M.get_sources()*
                           `M.get_sources`({null_ls})
Parameters ~
{null_ls} `(table)` The null-ls module
Return ~
`(table[])` List of source definitions


==============================================================================
------------------------------------------------------------------------------
                                                *get_undefined_prop_at_cursor()*
                    `get_undefined_prop_at_cursor`({params})
Parameters ~
{params} `(table)` null-ls params
Return ~
`(table|nil)` {prop_name: string, jsx_element_node: TSNode, value_node: TSNode}

------------------------------------------------------------------------------
                                                      *extract_component_name()*
             `extract_component_name`({bufnr}, {jsx_element_node})
Parameters ~
{bufnr} `(number)`
{jsx_element_node} `(TSNode)`
Return ~
`(string|nil)` component name

------------------------------------------------------------------------------
                                             *find_component_from_jsx_element()*
         `find_component_from_jsx_element`({bufnr}, {jsx_element_node})
Find component definition from JSX element
Parameters ~
{bufnr} `(number)`
{jsx_element_node} `(TSNode)`
Return ~
`(table|nil)` {bufnr: number, component_node: TSNode, file_path: string}

------------------------------------------------------------------------------
                                                     *infer_type_from_literal()*
                    `infer_type_from_literal`({value_node})
Parameters ~
{value_node} `(TSNode|nil)`
Return ~
`(string)` inferred type

------------------------------------------------------------------------------
                                                *extract_type_from_annotation()*
        `extract_type_from_annotation`({type_annotation_node}, {bufnr})
Parameters ~
{type_annotation_node} `(TSNode)`
{bufnr} `(number)`
Return ~
`(string|nil)` type string or nil

------------------------------------------------------------------------------
                                                   *find_variable_declaration()*
     `find_variable_declaration`({bufnr}, {identifier_name}, {start_node})
Parameters ~
{bufnr} `(number)`
{identifier_name} `(string)`
{start_node} `(TSNode)`
Return ~
`(TSNode|nil)` variable_declarator node or nil

------------------------------------------------------------------------------
                                                   *find_function_declaration()*
      `find_function_declaration`({bufnr}, {function_name}, {start_node})
Parameters ~
{bufnr} `(number)`
{function_name} `(string)`
{start_node} `(TSNode)`
Return ~
`(TSNode|nil)` function node with return type or nil

------------------------------------------------------------------------------
                                              *infer_type_from_arrow_function()*
            `infer_type_from_arrow_function`({bufnr}, {value_node})
Parameters ~
{bufnr} `(number)`
{value_node} `(TSNode)`
Return ~
`(string|nil)` inferred type or nil

------------------------------------------------------------------------------
                                        *infer_type_from_variable_declaration()*
     `infer_type_from_variable_declaration`({bufnr}, {value_node}, {depth})
Parameters ~
{bufnr} `(number)`
{value_node} `(TSNode)`
{depth} `(number|nil)` recursion depth (default 0)
Return ~
`(string|nil)` inferred type or nil

------------------------------------------------------------------------------
                                                   *infer_type_from_lsp_hover()*
               `infer_type_from_lsp_hover`({bufnr}, {value_node})
Parameters ~
{bufnr} `(number)`
{value_node} `(TSNode)`
Return ~
`(string|nil)` inferred type or nil

------------------------------------------------------------------------------
                                                                  *infer_type()*
                      `infer_type`({bufnr}, {value_node})
Parameters ~
{bufnr} `(number)`
{value_node} `(TSNode|nil)`
Return ~
`(string)` inferred type

------------------------------------------------------------------------------
                                                     *create_jsx_cleanup_edit()*
               `create_jsx_cleanup_edit`({_bufnr}, {value_node})
Parameters ~
{_bufnr} `(number)`
{value_node} `(TSNode|nil)`
Return ~
`(table[])` edits

------------------------------------------------------------------------------
                                                           *create_prop_edits()*
`create_prop_edits`({target_bufnr}, {comp_params}, {prop_name}, {prop_type}, {source_bufnr}, {value_node})
Parameters ~
{target_bufnr} `(number)` buffer where component is defined
{comp_params} `(table)` component params info
{prop_name} `(string)`
{prop_type} `(string)`
{source_bufnr} `(number|nil)` source buffer with JSX
{value_node} `(TSNode|nil)` value node from JSX
Return ~
`(table[])` edits

------------------------------------------------------------------------------
                                                                 *apply_edits()*
                        `apply_edits`({bufnr}, {edits})
Parameters ~
{bufnr} `(number)`
{edits} `(table[])`

------------------------------------------------------------------------------
                                                                *M.get_source()*
                           `M.get_source`({null_ls})
Get null-ls source
Parameters ~
{null_ls} `(table)`
Return ~
`(table)` source definition


==============================================================================
------------------------------------------------------------------------------
                                                                    *M.rename()*
                         `M.rename`({new_name}, {opts})
Enhanced rename with useState setter/state auto-renaming

Parameters ~
{new_name} `(string|nil)`: new name for the symbol
{opts} `(table|nil)`: additional options

------------------------------------------------------------------------------
                                                     *M.merge_workspace_edits()*
                      `M.merge_workspace_edits`({results})
Parameters ~
{results} `(table)`: results from vim.lsp.buf_request_all
Return ~
`(table|nil)`: merged workspace edit or nil

------------------------------------------------------------------------------
                                                       *M.add_secondary_edits()*
`M.add_secondary_edits`({workspace_edit}, {locations}, {_old_name}, {new_name})
Parameters ~
{workspace_edit} `(table)`: workspace edit to modify
{locations} `(table[])`: LSP Location objects
{_old_name} `(string)`: old symbol name (unused, uses locations)
{new_name} `(string)`: new symbol name

------------------------------------------------------------------------------
                                                  *is_likely_rename_operation()*
         `is_likely_rename_operation`({workspace_edit}, {bufnr}, {pos})
Check if workspace edit looks like a rename operation at cursor
Parameters ~
{workspace_edit} `(table)`
{bufnr} `(number)`
{pos} `(table)` cursor position {row, col}
Return ~
`(boolean)`

------------------------------------------------------------------------------
                                                   *M.try_add_use_state_edits()*
                 `M.try_add_use_state_edits`({workspace_edit})
Try to add useState secondary edits to workspace edit if applicable
Called during apply_workspace_edit hook for inc-rename integration

Parameters ~
{workspace_edit} `(table)`: workspace edit from LSP
Return ~
`(table|nil)`: enhanced workspace edit or nil if not useState

------------------------------------------------------------------------------
                                               *M.handle_props_workspace_edit()*
`M.handle_props_workspace_edit`({workspace_edit}, {bufnr}, {pos}, {props_info})
Parameters ~
{workspace_edit} `(table)`
{bufnr} `(number)`
{pos} `(table)`
{props_info} `(table)`
Return ~
`(table|nil)`

------------------------------------------------------------------------------
                                          *M.apply_direct_from_workspace_edit()*
       `M.apply_direct_from_workspace_edit`({pending}, {offset_encoding})
Parameters ~
{pending} `(table)` pending props edit context
{offset_encoding} `(string)` LSP offset encoding

------------------------------------------------------------------------------
                                  *M.apply_direct_from_destructure_inc_rename()*
   `M.apply_direct_from_destructure_inc_rename`({pending}, {offset_encoding})
Parameters ~
{pending} `(table)` pending props edit context
{offset_encoding} `(string)` LSP offset encoding

------------------------------------------------------------------------------
                                         *M.apply_direct_from_body_inc_rename()*
      `M.apply_direct_from_body_inc_rename`({pending}, {offset_encoding})
Parameters ~
{pending} `(table)`
{offset_encoding} `(string)`

------------------------------------------------------------------------------
                                                  *M.show_deferred_props_menu()*
                         `M.show_deferred_props_menu`()
Show deferred props rename menu after renaming

------------------------------------------------------------------------------
                                                      *M.cleanup_import_alias()*
                 `M.cleanup_import_alias`({bufnr}, {new_name})
Parameters ~
{bufnr} `(number)`
{new_name} `(string)`

------------------------------------------------------------------------------
                                                    *M.rename_props_in_buffer()*
    `M.rename_props_in_buffer`({import_bufnr}, {component_name}, {new_name})
Parameters ~
{import_bufnr} `(number)`: buffer containing component
{component_name} `(string)`: component name
{new_name} `(string)`: new component name

------------------------------------------------------------------------------
                                       *M.maybe_rename_props_in_imported_file()*
`M.maybe_rename_props_in_imported_file`({current_bufnr}, {import_path}, {component_name}, {new_name})
Parameters ~
{current_bufnr} `(number)`: current buffer with the import
{import_path} `(string)`: relative import path like "./Rename"
{component_name} `(string)`
{new_name} `(string)`

------------------------------------------------------------------------------
                                              *M.maybe_rename_props_same_file()*
    `M.maybe_rename_props_same_file`({bufnr}, {component_name}, {new_name})
Parameters ~
{bufnr} `(number)`
{component_name} `(string)`
{new_name} `(string)`

------------------------------------------------------------------------------
                                             *M.maybe_rename_props_cross_file()*
`M.maybe_rename_props_cross_file`({bufnr}, {component_name}, {new_name}, {import_info})
Parameters ~
{bufnr} `(number)`
{component_name} `(string)`
{new_name} `(string)`
{import_info} `(table|nil)`

------------------------------------------------------------------------------
                                           *M.handle_cross_file_direct_rename()*
`M.handle_cross_file_direct_rename`({cross_file_info}, {bufnr}, {pos}, {new_name})
Parameters ~
{cross_file_info} `(table)`
{bufnr} `(number)`
{pos} `(table)`
{new_name} `(string)`

------------------------------------------------------------------------------
                                             *M.show_deferred_cross_file_menu()*
                      `M.show_deferred_cross_file_menu`()
Show deferred cross-file rename menu after renaming


==============================================================================
------------------------------------------------------------------------------
                                                 *M.calculate_props_type_name()*
                `M.calculate_props_type_name`({component_name})
Parameters ~
{component_name} `(string)`: component name
Return ~
`(string)`: props type name

------------------------------------------------------------------------------
                                                  *M.calculate_component_name()*
                `M.calculate_component_name`({props_type_name})
Parameters ~
{props_type_name} `(string)`: props type name
Return ~
`(string|nil)`: component name or nil if not matching pattern

------------------------------------------------------------------------------
                                                         *M.is_component_name()*
                     `M.is_component_name`({bufnr}, {pos})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
Return ~
`(table|nil)`: {is_component: bool, component_name: string, props_type_name: string, type_location: table|nil}

------------------------------------------------------------------------------
                                                        *M.is_props_type_name()*
                     `M.is_props_type_name`({bufnr}, {pos})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
Return ~
`(table|nil)`: {is_props_type: bool, component_name: string, props_type_name: string, component_location: table|nil}

------------------------------------------------------------------------------
                                           *M.is_component_usage_in_same_file()*
              `M.is_component_usage_in_same_file`({bufnr}, {pos})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
Return ~
`(table)`: {is_usage: bool, component_name: string, props_type_name: string, type_location: table|nil}

------------------------------------------------------------------------------
                                                            *M.is_type_shared()*
                    `M.is_type_shared`({bufnr}, {type_name})
Parameters ~
{bufnr} `(number)`: buffer number
{type_name} `(string)`: type name to check
Return ~
`(boolean)`: true if type is used by multiple components

------------------------------------------------------------------------------
                                    *component_props.prepare_secondary_rename()*
            `M.prepare_secondary_rename`({bufnr}, {pos}, {new_name})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
{new_name} `(string)`: new name for primary symbol
Return ~
`(table|nil)`: {secondary_old: string, secondary_name: string, references: table[]}

------------------------------------------------------------------------------
                                 *component_props.prepare_secondary_from_edit()*
       `M.prepare_secondary_from_edit`({bufnr}, {pos}, {workspace_edit})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
{workspace_edit} `(table)`: workspace edit from LSP
Return ~
`(table|nil)`: {secondary_old: string, secondary_name: string, references: table[]}

------------------------------------------------------------------------------
                                                       *M.is_component_import()*
                    `M.is_component_import`({bufnr}, {pos})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
Return ~
`(table|nil)`: {is_import: bool, import_type: "named"|"default", component_name: string, import_path: string, import_node: TSNode}

------------------------------------------------------------------------------
                                                    *M.detect_component_usage()*
                   `M.detect_component_usage`({bufnr}, {pos})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
Return ~
`(table)`: {is_usage: bool, is_same_file: bool, component_name: string, props_type_name: string, type_location: table|nil, import_info: table|nil}

------------------------------------------------------------------------------
                                                *M.detect_cross_file_scenario()*
                 `M.detect_cross_file_scenario`({bufnr}, {pos})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
Return ~
`(table|nil)`: cross-file scenario info or nil if not cross-file


==============================================================================
------------------------------------------------------------------------------
                                                     *M.detect_prop_at_cursor()*
                   `M.detect_prop_at_cursor`({bufnr}, {pos})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
Return ~
`(table|nil)`: {is_prop: bool, prop_name: string, context: string} or nil

------------------------------------------------------------------------------
                                                    *M.detect_prop_treesitter()*
                      `M.detect_prop_treesitter`({bufnr})
Parameters ~
{bufnr} `(number)`: buffer number
Return ~
`(table|nil)`: prop info or nil

------------------------------------------------------------------------------
                                                        *M.is_react_component()*
                `M.is_react_component`({function_node}, {bufnr})
if function is a React component (PascalCase name + returns JSX)
Parameters ~
{function_node} `(TSNode)`
{bufnr} `(number)`
Return ~
`(boolean)`

------------------------------------------------------------------------------
                                                       *M.check_jsx_attribute()*
         `M.check_jsx_attribute`({bufnr}, {root}, {row}, {col}, {lang})
Parameters ~
{bufnr} `(number)`
{root} `(TSNode)`
{row} `(number)`
{col} `(number)`
{lang} `(string)`
Return ~
`(table|nil)`

------------------------------------------------------------------------------
                                                       *M.check_destructuring()*
         `M.check_destructuring`({bufnr}, {root}, {row}, {col}, {lang})
Parameters ~
{bufnr} `(number)`
{root} `(TSNode)`
{row} `(number)`
{col} `(number)`
{lang} `(string)`
Return ~
`(table|nil)`

------------------------------------------------------------------------------
                                                       *M.check_body_variable()*
        `M.check_body_variable`({bufnr}, {_root}, {row}, {col}, {_lang})
Parameters ~
{bufnr} `(number)`
{_root} `(TSNode)`
{row} `(number)`
{col} `(number)`
{_lang} `(string)`
Return ~
`(table|nil)`

------------------------------------------------------------------------------
                                                      *M.check_type_signature()*
        `M.check_type_signature`({bufnr}, {root}, {row}, {col}, {lang})
Parameters ~
{bufnr} `(number)`
{root} `(TSNode)`
{row} `(number)`
{col} `(number)`
{lang} `(string)`
Return ~
`(table|nil)`

------------------------------------------------------------------------------
                                                         *M.detect_prop_regex()*
                     `M.detect_prop_regex`({bufnr}, {pos})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
Return ~
`(table|nil)`: prop info or nil

------------------------------------------------------------------------------
                                                   *M.find_type_name_for_node()*
                      `M.find_type_name_for_node`({node})
Parameters ~
{node} `(TSNode)`
Return ~
`(string|nil)`: type/interface name if node is inside type declaration

------------------------------------------------------------------------------
                                                 *M.find_component_using_type()*
      `M.find_component_using_type`({bufnr}, {root}, {type_name}, {lang})
Parameters ~
{bufnr} `(number)`
{root} `(TSNode)`
{type_name} `(string)`
{lang} `(string)`
Return ~
`(TSNode|nil)`: function node that uses this type

------------------------------------------------------------------------------
                                                   *M.find_jsx_component_name()*
                      `M.find_jsx_component_name`({node})
Find JSX component name from node (walks up to jsx element)
Parameters ~
{node} `(TSNode)`
Return ~
`(string|nil)`: component name if in JSX usage

------------------------------------------------------------------------------
                                                    *M.find_component_by_name()*
     `M.find_component_by_name`({bufnr}, {root}, {component_name}, {lang})
Find component definition by name in buffer
Parameters ~
{bufnr} `(number)`
{root} `(TSNode)`
{component_name} `(string)`
{lang} `(string)`
Return ~
`(TSNode|nil)`: function node or nil

------------------------------------------------------------------------------
                                                     *M.find_component_import()*
      `M.find_component_import`({bufnr}, {root}, {component_name}, {lang})
Find component in imported files
Parameters ~
{bufnr} `(number)`
{root} `(TSNode)`
{component_name} `(string)`
{lang} `(string)`
Return ~
`(table|nil)`: {file_path: string, component_info: table}

------------------------------------------------------------------------------
                                                   *M.find_component_for_prop()*
       `M.find_component_for_prop`({bufnr}, {_prop_name}, {context_pos})
Parameters ~
{bufnr} `(number)`: buffer number
{_prop_name} `(string)`: prop name to find
{context_pos} `(table)`: cursor position where detection happened
Return ~
`(table|nil)`: component info or nil

------------------------------------------------------------------------------
                                                 *M.find_destructure_location()*
     `M.find_destructure_location`({bufnr}, {component_info}, {prop_name})
Parameters ~
{bufnr} `(number)`: buffer number
{component_info} `(table|nil)`: component info from find_component_for_prop
{prop_name} `(string)`: prop name to find
Return ~
`(table)`: {found: bool, range: table|nil, is_aliased: bool, current_alias: string|nil}

------------------------------------------------------------------------------
                                                         *M.create_alias_edit()*
   `M.create_alias_edit`({bufnr}, {destructure_info}, {old_name}, {new_name})
Parameters ~
{bufnr} `(number)`: buffer number
{destructure_info} `(table)`: destructure location info
{old_name} `(string)`: old prop name
{new_name} `(string)`: new prop name
Return ~
`(table)`: TextEdit for alias transformation

------------------------------------------------------------------------------
                                              *M.find_alias_variable_position()*
   `M.find_alias_variable_position`({bufnr}, {destructure_range}, {old_name})
position of alias variable in destructure pattern after first rename
first rename applied, buffer has { newName: oldName }, find position of oldName
Parameters ~
{bufnr} `(number)`
{destructure_range} `(table)` LSP range (original range before any edits)
{old_name} `(string)` original prop name to find in alias position
Return ~
`(table|nil)` LSP Position {line, character}

------------------------------------------------------------------------------
                                                         *M.find_key_position()*
        `M.find_key_position`({bufnr}, {destructure_range}, {key_name})
position of key in destructure pattern after renaming alias
renaming alias, buffer has { oldKey: newName }, find position of oldKey
Parameters ~
{bufnr} `(number)`
{destructure_range} `(table)` LSP range
{key_name} `(string)` the key name to find
Return ~
`(table|nil)` LSP Position {line, character}

------------------------------------------------------------------------------
                                            *M.convert_to_shorthand_in_buffer()*
              `M.convert_to_shorthand_in_buffer`({bufnr}, {name})
{ bar: bar } to { bar } in buffer after rename is applied
pair_pattern nodes where key and value match, converts to shorthand
Parameters ~
{bufnr} `(number)`
{name} `(string)` the prop name

------------------------------------------------------------------------------
                                                   *M.calculate_cursor_offset()*
            `M.calculate_cursor_offset`({bufnr}, {pos}, {prop_name})
Calculate cursor offset within prop name
@param bufnr number buffer number
@param pos table {row, col} cursor position (1-indexed row, 0-indexed col)
@param prop_name string the prop name at cursor
@return number|nil offset from start of prop name, or nil if can't determine

------------------------------------------------------------------------------
                                                   *M.restore_cursor_position()*
`M.restore_cursor_position`({bufnr}, {win}, {new_prop_name}, {original_pos}, {offset})
Restore cursor position after prop rename
@param bufnr number buffer number
@param win number window handle
@param new_prop_name string renamed prop name
@param original_pos table|nil original cursor position {row, col} (1-indexed row, 0-indexed col)
@param offset number cursor offset within prop name (0-indexed)


==============================================================================
------------------------------------------------------------------------------
                                                     *M.calculate_setter_name()*
                    `M.calculate_setter_name`({state_name})
Parameters ~
{state_name} `(string)`: state variable name
Return ~
`(string)`: setter name

------------------------------------------------------------------------------
                                                      *M.calculate_state_name()*
                    `M.calculate_state_name`({setter_name})
Parameters ~
{setter_name} `(string)`: setter variable name
Return ~
`(string|nil)`: state name or nil if not valid setter

------------------------------------------------------------------------------
                                                         *M.is_state_variable()*
                     `M.is_state_variable`({bufnr}, {pos})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
Return ~
`(table)`: {is_state: bool, setter_name: string, state_name: string}

------------------------------------------------------------------------------
                                                        *M.is_setter_variable()*
                     `M.is_setter_variable`({bufnr}, {pos})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
Return ~
`(table)`: {is_setter: bool, state_name: string, setter_name: string}

------------------------------------------------------------------------------
                                                        *M.get_rename_context()*
                     `M.get_rename_context`({bufnr}, {pos})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
Return ~
`(table|nil)`: {is_state_rename: bool, secondary_old: string, state_name: string, setter_name: string}

------------------------------------------------------------------------------
                                          *M.calculate_secondary_from_primary()*
     `M.calculate_secondary_from_primary`({new_primary}, {is_state_rename})
Parameters ~
{new_primary} `(string)`: new primary name
{is_state_rename} `(boolean)`: true if renaming state, false if setter
Return ~
`(string|nil)`: secondary name

------------------------------------------------------------------------------
                                          *use_state.prepare_secondary_rename()*
            `M.prepare_secondary_rename`({bufnr}, {pos}, {new_name})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
{new_name} `(string)`: new name for primary symbol
Return ~
`(table|nil)`: {secondary_old: string, secondary_name: string, references: table[]}

------------------------------------------------------------------------------
                                       *use_state.prepare_secondary_from_edit()*
       `M.prepare_secondary_from_edit`({bufnr}, {pos}, {workspace_edit})
Parameters ~
{bufnr} `(number)`: buffer number
{pos} `(table)`: cursor position {row, col}
{workspace_edit} `(table)`: workspace edit from LSP
Return ~
`(table|nil)`: {secondary_old: string, secondary_name: string, references: table[]}


==============================================================================
------------------------------------------------------------------------------
                                                *M.extract_new_name_from_edit()*
                `M.extract_new_name_from_edit`({workspace_edit})
Parameters ~
{workspace_edit} `(table)`: workspace edit from LSP
Return ~
`(string|nil)`: new name from first edit

------------------------------------------------------------------------------
                                                           *M.find_references()*
                  `M.find_references`({bufnr}, {symbol_name})
Parameters ~
{bufnr} `(number)`: buffer number
{symbol_name} `(string)`: symbol to find
Return ~
`(table[])`: array of LSP-like Location objects

------------------------------------------------------------------------------
                                                            *M.check_conflict()*
                    `M.check_conflict`({bufnr}, {new_name})
Parameters ~
{bufnr} `(number)`: buffer number
{new_name} `(string)`: proposed new name
Return ~
`(boolean)`: true if conflict exists


==============================================================================
------------------------------------------------------------------------------
                                                          *M.show_rename_menu()*
      `M.show_rename_menu`({old_name}, {new_name}, {context}, {callback})
Parameters ~
{old_name} `(string)`: original prop name
{new_name} `(string)`: new prop name
{context} `(string)` Rename target context (e.g. "jsx", "body", "type")
{callback} `(function)`: callback with choice ("direct" or "alias")

------------------------------------------------------------------------------
                                               *M.show_cross_file_rename_menu()*
      `M.show_cross_file_rename_menu`({old_name}, {new_name}, {callback})
Parameters ~
{old_name} `(string)`: original component name
{new_name} `(string)`: new component name
{callback} `(function)`: callback with choice ("direct" or "alias")


==============================================================================
------------------------------------------------------------------------------
                                                                *M.has_parser()*
                        `M.has_parser`({bufnr}, {lang})
Parameters ~
{bufnr} `(number)`: buffer number
{lang} `(string)`: language name (e.g., "javascript", "typescript")
Return ~
`(boolean)`: true if parser is available

------------------------------------------------------------------------------
                                                        *M.get_node_at_cursor()*
                        `M.get_node_at_cursor`({bufnr})
Parameters ~
{bufnr} `(number)`: buffer number
Return ~
`(TSNode|nil)`: node at cursor or nil

------------------------------------------------------------------------------
                                                  *M.find_use_state_at_cursor()*
                     `M.find_use_state_at_cursor`({bufnr})
Find useState pattern at cursor position

Parameters ~
{bufnr} `(number)`: buffer number
Return ~
`(table|nil)`: {state_var: string, setter_var: string, state_range: table, setter_range: table} or nil


 vim:tw=78:ts=8:noet:ft=help:norl: